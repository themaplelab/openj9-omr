#include "optimizer/IDTBuilder.hpp"
#include "optimizer/AbsInterpreter.hpp"

IDTBuilder::IDTBuilder(TR::ResolvedMethodSymbol* symbol, int32_t budget, TR::Region& region, TR::Compilation* comp, OMR::BenefitInliner* inliner) :
      _rootSymbol(symbol),
      _rootBudget(budget),
      _region(region),
      _comp(comp),
      _inliner(inliner),
      _cfgGen(NULL),
      _idt(NULL),
      _valuePropagation(NULL),
      _util(NULL),
      _callSiteIndex(0),
      _interpretedMethodMap(InterpretedMethodMapComparator(), InterpretedMethodMapAllocator(region))
   {
   }

OMR::BenefitInlinerUtil* IDTBuilder::getUtil()
   {
   if (!_util)
      _util = new (comp()->allocator()) OMR::BenefitInlinerUtil(comp());
   return _util;
   }

TR::CFG* IDTBuilder::generateCFG(TR_CallTarget* callTarget, TR_CallStack* callStack)
   {
   if (!_cfgGen)
      {
      _cfgGen = (TR_J9EstimateCodeSize *)TR_EstimateCodeSize::get(getInliner(), getInliner()->tracer(), 0);   
      }

   TR::CFG* cfg = _cfgGen->generateCFG(callTarget, callStack, region());
   return cfg;
   }

TR::ValuePropagation* IDTBuilder::getValuePropagation()
   {
   if (!_valuePropagation)
      {
      TR::OptimizationManager* manager = comp()->getOptimizer()->getOptimization(OMR::globalValuePropagation);
      _valuePropagation = (TR::ValuePropagation*) manager->factory()(manager);
      _valuePropagation->initialize();
      }
   return _valuePropagation;
   }
   
IDT* IDTBuilder::buildIDT()
   {
   bool traceBIIDTGen = comp()->getOption(TR_TraceBIIDTGen);

   if (traceBIIDTGen)
      traceMsg(comp(), "\n+ IDTBuilder: Start building IDT |\n\n");
   
   //root call target
   TR_ResolvedMethod* rootMethod = _rootSymbol->getResolvedMethod();
   TR_CallTarget *rootCallTarget = new (region()) TR_CallTarget(
                                    NULL,
                                    _rootSymbol, 
                                    rootMethod, 
                                    NULL, 
                                    rootMethod->containingClass(), 
                                    NULL);
   
   //Initialize IDT
   _idt = new (region()) IDT(region(), _rootSymbol, rootCallTarget, _rootBudget, comp());
   IDTNode* root = _idt->getRoot();

   //add the decendants
   buildIDTHelper(root, NULL, -1, _rootBudget, NULL);

   if (traceBIIDTGen)
      traceMsg(comp(), "\n+ IDTBuilder: Finish building IDT |\n");

   return _idt;
   }

void IDTBuilder::buildIDTHelper(IDTNode* node, AbsState* invokeState, int callerIndex, int32_t budget, TR_CallStack* callStack)
   {

   TR::ResolvedMethodSymbol* symbol = node->getResolvedMethodSymbol();
   TR_ResolvedMethod* method = symbol->getResolvedMethod();
   

   bool traceBIIDTGen = comp()->getOption(TR_TraceBIIDTGen);
   if (traceBIIDTGen)
      traceMsg(comp(), "+ IDTBuilder: Adding children for IDTNode: %s\n",node->getName(comp()->trMemory()));
   
   if (callStack == NULL) //This is the root method
      {
      TR::CFG* cfg = generateCFG(node->getCallTarget());
      cfg->computeInitialBlockFrequencyBasedOnExternalProfiler(comp());
      cfg->setFrequencies();
      symbol->setFlowGraph(cfg);
      cfg->getStartForReverseSnapshot()->setFrequency(cfg->getStartBlockFrequency());
      }
   else //cfg has already been set in computeCallRatio()
      {
      TR::CFG* cfg = node->getCallTarget()->_cfg;
      cfg->getStartForReverseSnapshot()->setFrequency(cfg->getStartBlockFrequency());
      }

   TR_CallStack* nextCallStack = new (region()) TR_CallStack(comp(), symbol, method, callStack, budget, true);

   IDTNode* interpretedMethodIDTNode = getInterpretedMethod(node->getResolvedMethodSymbol());
   
   if (interpretedMethodIDTNode)
      {
      int staticBenefit = computeStaticBenefitWithMethodSummary(symbol->getMethod(), 
                                                               symbol->getMethodKind() == TR::MethodSymbol::Kinds::Static,
                                                               interpretedMethodIDTNode->getMethodSummary(),  //use the method summary of the same method IDTNode
                                                               invokeState);
      node->setStaticBenefit(staticBenefit);
      _idt->copyDescendants(interpretedMethodIDTNode, node); //IDT is built in DFS order, at this time, we have all the descendants so it is safe to copy the descendants
      return;
      }
   else
      {
      performAbstractInterpretation(node, callerIndex, nextCallStack);

      //At this point we have the method summary generated by abstract interpretation
      if (!node->isRoot())
         {
         int staticBenefit = computeStaticBenefitWithMethodSummary(symbol->getMethod(), 
                                                                     symbol->getMethodKind() == TR::MethodSymbol::Kinds::Static,
                                                                     node->getMethodSummary(), 
                                                                     invokeState);
         node->setStaticBenefit(staticBenefit); 
         }
      
      addInterpretedMethod(node->getResolvedMethodSymbol(), node); //store this method to already interpreted method map
      }
   
   return;
   }

//Abstract interpetation = identifying call targets in the method body + generating method summary for the method being interpreted
void IDTBuilder::performAbstractInterpretation(IDTNode* node, int callerIndex, TR_CallStack* callStack)
   {
   AbsInterpreter interpreter(node, callerIndex, this, getValuePropagation(), callStack, region(), comp());
   interpreter.interpret();
   }

IDTNode* IDTBuilder::getInterpretedMethod(TR::ResolvedMethodSymbol* symbol)
   {
   TR_ResolvedMethod* method = symbol->getResolvedMethod();
   TR_OpaqueMethodBlock* persistentIdentifier = method->getPersistentIdentifier();

   auto iter = _interpretedMethodMap.find(persistentIdentifier);
   if (iter == _interpretedMethodMap.end()) //Not interpreted yet
      return NULL;
   
   return iter->second;
   }

void IDTBuilder::addInterpretedMethod(TR::ResolvedMethodSymbol* symbol, IDTNode* node)
   {
   TR_ResolvedMethod* method = symbol->getResolvedMethod();
   TR_OpaqueMethodBlock* persistentIdentifier = method->getPersistentIdentifier();

   _interpretedMethodMap.insert(std::pair<TR_OpaqueMethodBlock *, IDTNode *>(persistentIdentifier,node));
   }

void IDTBuilder::addChild(IDTNode*node, int callerIndex, TR::Method* calleeMethod, bool isStaticMethod, TR_CallSite* callSite, AbsState* invokeState, TR_CallStack* callStack, TR::Block* block)
   {
   bool traceBIIDTGen = comp()->getOption(TR_TraceBIIDTGen);

   if (callSite == NULL)
      {
      cleanInvokeState(calleeMethod, isStaticMethod, invokeState); //setting method summary as NULL will clean the AbsState. (Pop the paramters from the Op Stack)
      return;
      }

   getInliner()->applyPolicyToTargets(callStack, callSite, block, node->getCallTarget()->_cfg); // eliminate call targets that are not inlinable. 

   if (callSite->numTargets() == 0) 
      {
      cleanInvokeState(calleeMethod, isStaticMethod, invokeState);
      return;
      }
      
   //There should be only one call Target in callsite (disable multiTargetInlining)
   TR_CallTarget* callTarget = callSite->getTarget(0);

   int remainingBudget = node->getBudget() - callTarget->_calleeMethod->maxBytecodeIndex();
   if (remainingBudget < 0 ) // no budget remains, stop building IDT.
      {
      cleanInvokeState(calleeMethod, isStaticMethod, invokeState);
      return;
      }

   bool isRecursiveCall = callStack->isAnywhereOnTheStack(callTarget->_calleeMethod, 1);
   if (isRecursiveCall) //Stop for recursive call
      {
      cleanInvokeState(calleeMethod, isStaticMethod, invokeState);
      return;
      }
   
   TR::ResolvedMethodSymbol * calleeMethodSymbol = TR::ResolvedMethodSymbol::create(comp()->trHeapMemory(), callTarget->_calleeMethod, comp());

   //At this point we have the callsite, next thing is to compute the call ratio of the call target.
   float callRatio = computeCallRatio(callTarget, callStack, block, node->getCallTarget()->_cfg);

   IDTNode* child = node->addChild(
                           _idt->getNextGlobalIDTNodeIndex(),
                           callTarget,
                           callSite->_byteCodeIndex,
                           calleeMethodSymbol,
                           callRatio,
                           _idt->getMemoryRegion()
                           );

   if (child == NULL) // Fail to add the Node to IDT
      {
      computeStaticBenefitWithMethodSummary(calleeMethod, isStaticMethod, NULL, invokeState);
      return;
      }
   
   //If successfully add this child to the IDT

   _idt->increaseGlobalIDTNodeIndex();

   if (!comp()->incInlineDepth(calleeMethodSymbol, callSite->_bcInfo, callSite->_cpIndex, NULL, !callSite->isIndirectCall(), 0))
      {
      computeStaticBenefitWithMethodSummary(calleeMethod, isStaticMethod, NULL, invokeState);
      return;
      }

   // Build the IDT recursively
   buildIDTHelper(child, invokeState, callerIndex + 1, child->getBudget(), callStack);

   comp()->decInlineDepth(true); 

   if (traceBIIDTGen)
      traceMsg(comp(), "+ IDTBuilder: add child: %s to parent: %s\n",child->getName(comp()->trMemory()),node->getName(comp()->trMemory()));
      
   }

float IDTBuilder::computeCallRatio(TR_CallTarget* callTarget, TR_CallStack* callStack, TR::Block* block, TR::CFG* callerCfg)
   {
   TR_ASSERT_FATAL(callTarget, "Call Target is NULL!");

   TR::CFG* cfg = generateCFG(callTarget, callStack); //Now the callTarget has its own CFG
   TR::ResolvedMethodSymbol *caller = callStack->_methodSymbol;

   cfg->computeMethodBranchProfileInfo(getUtil(), callTarget, caller, _callSiteIndex++, block, callerCfg);

   return ((float)block->getFrequency() / (float) callerCfg->getStartBlockFrequency());  
   }

void IDTBuilder::cleanInvokeState(TR::Method* calleeMethod, bool isStaticMethod, AbsState* invokeState)
   {
   computeStaticBenefitWithMethodSummary(calleeMethod, isStaticMethod, NULL, invokeState);
   }

int IDTBuilder::computeStaticBenefitWithMethodSummary(TR::Method* calleeMethod, bool isStaticMethod, MethodSummary* methodSummary, AbsState* invokeState)
   {
   TR_ASSERT_FATAL(invokeState, "invoke state is NULL");

   traceMsg(comp(), "#### Invoke State ####\n");
   //printf("=== compute benefit===\n ");
   invokeState->trace(_valuePropagation);

   ////printf("=== %s\n",calleeMethod->signature(comp()->trMemory()));

   uint32_t numExplicitParams = calleeMethod->numberOfExplicitParameters();

   uint32_t numImplicitParams = isStaticMethod ? 0 : 1;

   uint32_t totalNumParams = numImplicitParams + numExplicitParams; 

   AbsValue *paramsArray[totalNumParams];

   for (uint32_t i = 0 ; i < numExplicitParams; i ++)
      {
      AbsValue* absValue = invokeState->pop();
      AbsValue* absValue2 = NULL;

      TR::DataType dataType = calleeMethod->parmType(numExplicitParams -i - 1);
      ////printf("Param %d, Type: %s\n",numExplicitParams -i - 1, TR::DataType::getName(dataType));
      if (dataType == TR::Double || dataType == TR::Int64)
         absValue2 = invokeState->pop();

      paramsArray[totalNumParams -i - 1] = absValue2 ? absValue2 : absValue;
      }

   if (numImplicitParams == 1)
      paramsArray[0] = invokeState->pop();

   if (methodSummary == NULL) //if we do not have method summary
      return 0;

   int benefit = 0;

   for (uint32_t i = 0; i < totalNumParams; i ++)
      {
      AbsValue* value = paramsArray[i];
      benefit += methodSummary->predicates(value->getConstraint(), i);
      }
   
   return benefit;
   }

