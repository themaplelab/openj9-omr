#include "optimizer/IDTBuilder.hpp"
#include "optimizer/AbsInterpreter.hpp"

IDTBuilder::IDTBuilder(TR::ResolvedMethodSymbol* symbol, int32_t budget, TR::Region& region, TR::Compilation* comp, OMR::BenefitInliner* inliner) :
      _rootSymbol(symbol),
      _rootBudget(budget),
      _region(region),
      _comp(comp),
      _inliner(inliner),
      _idt(NULL),
      _interpretedMethodMap(InterpretedMethodMapComparator(), InterpretedMethodMapAllocator(region))
   {
   }

void IDTBuilder::visit(TR_CallSite* callSite, AbsArguments* arguments)
   {
   printf("%s\n", callSite->signature(comp()->trMemory()));
   }

//The CFG is generated from EstimateCodeSize. It is different from a normal CFG. 
TR::CFG* IDTBuilder::generateFlowGraph(TR_CallTarget* callTarget, TR_CallStack* callStack)
   {
   TR_J9EstimateCodeSize* cfgGen = (TR_J9EstimateCodeSize *)TR_EstimateCodeSize::get(getInliner(), getInliner()->tracer(), 0);   
   TR::CFG* cfg = cfgGen->generateCFG(callTarget, callStack, region());
   if (cfg)
      {
      cfg->setFrequencies();
      cfg->setStartBlockFrequency();
      }
   return cfg;
   }


IDT* IDTBuilder::buildIDT()
   {
   bool traceBIIDTGen = comp()->getOption(TR_TraceBIIDTGen);

   if (traceBIIDTGen)
      traceMsg(comp(), "\n+ IDTBuilder: Start building IDT |\n\n");
   
   //root call target
   TR_ResolvedMethod* rootMethod = _rootSymbol->getResolvedMethod();

   TR_CallTarget *rootCallTarget = new (region()) TR_CallTarget(
                                    NULL,
                                    _rootSymbol, 
                                    rootMethod, 
                                    NULL, 
                                    rootMethod->containingClass(), 
                                    NULL);
   
   //Initialize IDT
   _idt = new (region()) IDT(region(), rootCallTarget, _rootSymbol, _rootBudget, comp());
   
   IDTNode* root = _idt->getRoot();

   //generate the CFG for root call target 
   TR::CFG* cfg = generateFlowGraph(rootCallTarget);

   if (!cfg) //Fail to generate a CFG
      return _idt;

   //setCFGBlockFrequency(rootCallTarget, true);
   
   //add the decendants
   buildIDTHelper(root, NULL, -1, _rootBudget, NULL);

   if (traceBIIDTGen)
      traceMsg(comp(), "\n+ IDTBuilder: Finish building IDT |\n");

   return _idt;
   }

void IDTBuilder::buildIDTHelper(IDTNode* node, AbsArguments* parameters, int callerIndex, int32_t budget, TR_CallStack* callStack)
   {
   TR::ResolvedMethodSymbol* symbol = node->getResolvedMethodSymbol();
   TR_ResolvedMethod* method = symbol->getResolvedMethod();
   
   bool traceBIIDTGen = comp()->getOption(TR_TraceBIIDTGen);

   TR_CallStack* nextCallStack = new (region()) TR_CallStack(comp(), symbol, method, callStack, budget, true);

   IDTNode* interpretedMethodIDTNode = getInterpretedMethod(symbol);
   
   if (interpretedMethodIDTNode)//If this method has been already interpreted
      {
      node->setMethodSummary(interpretedMethodIDTNode->getMethodSummary()); //since they are the same method, they should have the same method summary. 
      int staticBenefit = computeStaticBenefitWithMethodSummary(node->getMethodSummary(), parameters);

      node->setStaticBenefit(staticBenefit);
      _idt->copyDescendants(interpretedMethodIDTNode, node); //IDT is built in DFS order, at this point, we have all the descendants so it is safe to copy the descendants
      return;
      }
   else
      {
      performAbstractInterpretation(node, callerIndex, nextCallStack);

      //At this point we have the method summary generated by abstract interpretation
      if (!node->isRoot())
         {
         int staticBenefit = computeStaticBenefitWithMethodSummary(node->getMethodSummary(), parameters);
         node->setStaticBenefit(staticBenefit); 
         }
      
      addInterpretedMethod(symbol, node); //store this method to already interpreted method map
      }
   
   return;
   }

//Abstract interpetation = Walk the bytecode + identifying invoke bytecode + update AbsState + generate method summary
void IDTBuilder::performAbstractInterpretation(IDTNode* node, int callerIndex, TR_CallStack* callStack)
   {
   AbsInterpreter interpreter(node->getResolvedMethodSymbol(), node->getCallTarget()->_cfg, region(), comp());
   bool success = interpreter.interpret();
   if (!success)
      {
      if (comp()->getOption(TR_TraceAbstractInterpretation))
         traceMsg(comp(), "Fail to interpret method: %s\n", node->getName(comp()->trMemory()));
      }
   }

IDTNode* IDTBuilder::getInterpretedMethod(TR::ResolvedMethodSymbol* symbol)
   {
   TR_ResolvedMethod* method = symbol->getResolvedMethod();
   TR_OpaqueMethodBlock* persistentIdentifier = method->getPersistentIdentifier();

   auto iter = _interpretedMethodMap.find(persistentIdentifier);
   if (iter == _interpretedMethodMap.end()) //Not interpreted yet
      return NULL;
   
   return iter->second;
   }

void IDTBuilder::addInterpretedMethod(TR::ResolvedMethodSymbol* symbol, IDTNode* node)
   {
   TR_ResolvedMethod* method = symbol->getResolvedMethod();
   TR_OpaqueMethodBlock* persistentIdentifier = method->getPersistentIdentifier();

   _interpretedMethodMap.insert(std::pair<TR_OpaqueMethodBlock *, IDTNode *>(persistentIdentifier,node));
   }

void IDTBuilder::addChild(IDTNode*node, int callerIndex, TR_CallSite* callSite, AbsArguments* parameters, TR_CallStack* callStack, TR::Block* block)
   {
   bool traceBIIDTGen = comp()->getOption(TR_TraceBIIDTGen);

   if (callSite == NULL || callSite->_initialCalleeMethod == NULL)
      {
      if (traceBIIDTGen)
         traceMsg(comp(), "Do not have a callsite. Don't add\n");
      return;
      }
   
   if (block->getFrequency() < 6) //cold block. Do not worth adding it to the IDT.
      {
      if (traceBIIDTGen)
         traceMsg(comp(), "Cold block. Don't add\n");
      return;
      }

   
   callSite->findCallSiteTarget(callStack, getInliner()); //Find all call targets

   getInliner()->applyPolicyToTargets(callStack, callSite); // eliminate call targets that are not inlinable thus they won't be added to IDT 

   if (callSite->numTargets() == 0) 
      {
      if (traceBIIDTGen)
         traceMsg(comp(), "Do not have a call target. Don't add\n");
      return;
      }
      
   for (int i = 0 ; i < callSite->numTargets(); i++)
      {
      TR_CallTarget* callTarget = callSite->getTarget(0);
      
      int remainingBudget = node->getBudget() - callTarget->_calleeMethod->maxBytecodeIndex();
      if (remainingBudget < 0 ) // no budget remains, stop building IDT.
         {
         if (traceBIIDTGen)
            traceMsg(comp(), "No budget left. Don't add\n");
         continue;
         }

      bool isRecursiveCall = callStack->isAnywhereOnTheStack(callTarget->_calleeMethod, 1);
      if (isRecursiveCall) //Stop for recursive call
         {
         if (traceBIIDTGen)
            traceMsg(comp(), "Recursive call. Don't add\n");  
         continue;
         }
         
      //The actual symbol for the callTarget->_calleeMethod.
      TR::ResolvedMethodSymbol* calleeMethodSymbol = TR::ResolvedMethodSymbol::create(comp()->trHeapMemory(),callTarget->_calleeMethod, comp());

      //generate the CFG of this call target and set the block frequencies. 
      TR::CFG* cfg = generateFlowGraph(callTarget, callStack);

      if (!cfg)
         {
         if (traceBIIDTGen)
            traceMsg(comp(), "Fail to generate a CFG. Don't add\n");  
         continue;
         }
         
      

      if (traceBIIDTGen)
         traceMsg(comp(), "+ IDTBuilder: Adding a child Node: %s for IDTNode: %s\n", calleeMethodSymbol->signature(comp()->trMemory()), node->getName(comp()->trMemory()));

      float callRatio = computeCallRatio(block, node->getCallTarget()->_cfg);

      if (traceBIIDTGen)
         {
         traceMsg(comp(), "Block Freq: %d, Start Block Freq: %d, Call Ratio: %f \n", block->getFrequency(), node->getCallTarget()->_cfg->getStartBlockFrequency(), callRatio);
         }

      IDTNode* child = node->addChild(
                              _idt->getNextGlobalIDTNodeIndex(),
                              callTarget,
                              calleeMethodSymbol,
                              callSite->_byteCodeIndex,
                              callRatio,
                              _idt->getMemoryRegion()
                              );
      if (traceBIIDTGen)
         traceMsg(comp(), child != NULL ? "success\n" : "fail\n");
      
      if (child == NULL) // Fail to add the Node to IDT
         continue;
      
      //If successfully add this child to the IDT
      _idt->increaseGlobalIDTNodeIndex();

      if (!comp()->incInlineDepth(calleeMethodSymbol, callSite->_bcInfo, callSite->_cpIndex, NULL, !callSite->isIndirectCall(), 0))
         continue;
      
      // Build the IDT recursively
      buildIDTHelper(child, parameters, callerIndex + 1, child->getBudget(), callStack);

      comp()->decInlineDepth(true); 
         
      }
   }
   

float IDTBuilder::computeCallRatio(TR::Block* block, TR::CFG* callerCfg)
   {
   float callRatio = ((float)block->getFrequency() / (float) callerCfg->getStartBlockFrequency());
   return callRatio;  
   }

int IDTBuilder::computeStaticBenefitWithMethodSummary(MethodSummary* methodSummary, AbsArguments* parameterArray)
   {
   TR_ASSERT_FATAL(parameterArray, "parameter array is NULL");

   if (methodSummary == NULL) //if we do not have method summary
      return 0;

   int benefit = 0;

   for (size_t i = 0; i < parameterArray->size(); i ++)
      {
      AbsValue* param = parameterArray->at(i);
      benefit += methodSummary->predicates(param->getConstraint(), i);
      }
   // if (benefit >0)
   //    printf("%d\n",benefit);
   return benefit;
   }

